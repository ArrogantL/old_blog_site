<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String到底在内存中是如何存储的]]></title>
    <url>%2FString%E5%88%B0%E5%BA%95%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%2F</url>
    <content type="text"><![CDATA[String会出现在哪些地方方法内的局部string类内的字段Stringstatic string容器中存储的stringString数组那么String的位置会影响其存储方式吗？显然是不会的，类永远只会储存在堆上。但是实际上类的字段并不是一直在堆上的。String的构造方法以下来自String类 源码，一些无关紧要的实现被我省略了： private final char value[]; private int hash; // Default to 0 private static final long serialVersionUID = -6849794470754667710L; private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; public String() { this.value = “”.value; } public String(String original) { this.value = original.value;//底层char[]指向了同一位置！ this.hash = original.hash; } public String(char value[]) { this.value = Arrays.copyOf(value, value.length);//底层char[]指向不同位置！下面的截取也是如此 } public String(char value[], int offset, int count) { … } public String(int[] codePoints, int offset, int count) {...} public String(byte ascii[], int hibyte, int offset, int count) {...} public String(byte ascii[], int hibyte) {...} 我们可以发现String的构造器并不关注是否将char[]指向同一位置，之所以有一些没有指向同一位置完全是为了保证char[]是immutable的。这并不能说明调用构造器构造的String的内存位置有什么特别之处。 String另一种构造方式–为包装类型提供的专有构造方式运行如下代码： class StringPointerTest{ String g=”gh”,h=”gh”;}public class StringTest { public static void main(String[] args) { String a=”abc”; String b=”abc”; System.out.println(a==b);//true使用简写的构造能够复用创建的string类 String c=new String(“abc”); System.out.println(a==c);//false是用构造器则不能 String d=new String(“def”); String e=”def”； System.out.println(d==e);//false即使先构造器再使用简化构造也不行。 StringPointerTest spt=new StringPointerTest(); System.out.println(spt.g==spt.h); //true与String的属于方法局部变量还是类字段也无关 }}class IntegerPointTest1{ Integer a=1; }class IntegerPointTest2{ Integer b=1;}public class IntegerTest { public static void main(String[] args) { System.out.println(new IntegerPointTest1().a==new IntegerPointTest2().b);//true! }}原理需要存储的代码元素有： Class类文件方法，类的所以实例应该共用一段方法static字段字符串常量值常量类实例各种引用基本变量他们各自有各自的存储位置，方法内的引用存在方法栈，类内的引用存在堆，类存储在堆上，方法中的局部基本变量存于栈但是类字段的基本变量存在堆上（方法区内）。值得一提的是方法区（又叫静态区），其存储值常量、字符串常量、方法、静态字段、.class文件，等只用一个备份的数据。栈和方法区都有共享数据的功能。因此使用简化方法构造String类的时候，在方法内和类内会将字符串存于栈/方法区，这无关紧要，重要的是，使用这种构造方法，如果没有所构造的字符串常量存在于内存中，那么会在栈/方法区中存上一份，然后再堆中新建一个String类，把String类的char[]引用指向在栈/方法区中的字符串常量；如果所构造的字符串常量已经存在于内存中，那么则会检索关联与之对应的堆中String实例，并直接使用这个String类实例。只有使用简化方法构造才能被栈/方法区记录下来，如果使用new则不行，这也是为什么上例即使先new，再使用简化构造相同字符串也不会引用相同。因为new出来的String实例的字符串常量存储在堆上，和栈/方法区无关。拓展到所有包装类型—可以吗？完全不可以。他们都没有像String那样实现缓存。但是实现了类似的缓存，它们的自动包装机制也提供缓存功能，但是是基于valueof方法的，该方法会对一定范围内进行缓存。而且实现方式非常暴力,是在对应类里存一个静态的类数组，并静态初始化全部填充。 可以缓存的范围：byte Byte -128–127short Short -128–127int Integer -128—127long Long -128—127char Character 0–127boolean Boolean TURE，FALSEString不缓存的：float Floatdouble Double 可见不是所有的自动包装机制都实现了全缓存。]]></content>
      <categories>
        <category>java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scanner分析]]></title>
    <url>%2FScanner%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[scanner错误关闭导致的异常public class test2 { public static void main(String[] args) { Scanner scanner1 = new Scanner(System.in); System.out.println(“run scanner1.close()”); scanner1.close(); Scanner scanner2 = new Scanner(System.in); System.out.println(&quot;run scanner2.nextLine()&quot;); scanner2.nextLine(); }}但是会在scanner2.nextLine()调用时抛出异常java.util.NoSuchElementException: No line found 原因下面是scanner的源码 // The input source private Readable source;public void close() { if (closed) return; if (source instanceof Closeable) { try { ((Closeable)source).close(); } catch (IOException ioe) { lastException = ioe; } } sourceClosed = true; source = null; closed = true; }所以调用close方法并不仅仅关闭scanner类，同时关闭了初始化时作为参数传入的Readable对象。在示例代码中scanner1.close();关闭了System.in，所以虽然初始化scanner2没有问题，但是readLine()会报错。 是否可以通过重新开启System.in的方式补救呢？遗憾的是，至少作为java的使用者来说是不可以的，除非我们能控制jvm运行。这涉及到System.in是如何开启的，简单来说因为System.in是特殊的系统资源，由jvm负责开启,无法通过java代码重新初始化System.in。如果查看System.in的代码我们就能发现它通过native方法实现初始化，在native方法中将控制台或文件句柄传输给System.in来完成。同样的,Systerm.out System.err也是无法重新被开启的资源，对于它们，close方法应该被谨慎的调用。（ps：实际上有什么原因关闭呢？） 让我们把问题拓展开来实际上，所有的能够以System.in/out/err为构造器参数的包装器类的close方法都应该被考虑，可以看到jdk的设计者并没有区别对待普通的流和System.in/out/err，而包装器类的close方法关闭底层流对于普通流来说是很合理的，因此我们可以推测事实上其他的包装器的close方法也可能导致关闭System.in/out/err。常用的bufferinputstream就是如此。 jdk7引入的带资源的try语法糖产生隐蔽的问题jdk7引入的带资源的try语法糖隐式的帮助程序员调用close方法,遗憾的是该方法也会产生上述问题，甚至更难被发现。 我们有必要积极的关闭不再需要的流嘛？如何对待io.close?如何预防该问题？从性能的角度来说，积极关闭流是必须的，实际上如果我们使用findbugs等代码规范工具，能发现关闭io是被强烈推荐的。如果你使用idea的话，建议在close之前，使用快捷键ctrl+b进入close方法的源代码来查看其关闭机制。这种方法非常简便，当然eclipse应该也有插件可以实现类似功能。我们也可以通过包装System.in/out/err来安全的使用它们，实际上利用装饰器模式，覆盖System.in/out/err的close方法即可。]]></content>
      <categories>
        <category>java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>scanner</tag>
        <tag>底层</tag>
      </tags>
  </entry>
</search>
