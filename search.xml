<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[著作权通识]]></title>
    <url>%2F%E8%91%97%E4%BD%9C%E6%9D%83%E9%80%9A%E8%AF%86%2F</url>
    <content type="text"><![CDATA[著作权==版权《中华人民共和国著作权法》第57条：本法所称著作权即版权。 合理使用第二十二条 在下列情况下使用作品，可以不经著作权人许可，不向其支付报酬，但应当指明作者姓名、作品名称，并且不得侵犯著作权人依照本法享有的其他权利： ​ （一）为个人学习、研究或者欣赏，使用他人已经发表的作品；（仅供个人欣赏，请于下载24小时内删除） ​ （二）为介绍、评论**某一作品或者说明某一问题**，在作品中适当引用他人已经发表的作品；（影评剪辑引用原片；评论时事使用媒体照片） ​ （三）为报道时事新闻，在报纸、期刊、广播电台、电视台等媒体中不可避免地再现或者引用已经发表的作品； ​ （四）报纸、期刊、广播电台、电视台等媒体刊登或者播放其他报纸、期刊、广播电台、电视台等媒体已经发表的关于政治、经济、宗教问题的时事性文章，但作者声明不许刊登、播放的除外； ​ （五）报纸、期刊、广播电台、电视台等媒体刊登或者播放在公众集会上发表的讲话，但作者声明不许刊登、播放的除外； ​ （六）为学校课堂教学或者科学研究，翻译或者少量复制已经发表的作品，供教学或者科研人员使用，但不得出版发行；（学校老师复印考卷） ​ （七）国家机关为执行公务在合理范围内使用已经发表的作品； ​ （八）图书馆、档案馆、纪念馆、博物馆、美术馆等为陈列或者保存版本的需要，复制本馆收藏的作品； ​ （九）免费表演已经发表的作品，该表演未向公众收取费用，也未向表演者支付报酬； ​ （十）对设置或者陈列在室外公共场所的艺术作品进行临摹、绘画、摄影、录像；（网上流传的文物相片，以及毛泽东标准肖像） ​ （十一）将中国公民、法人或者其他组织已经发表的以汉语言文字创作的作品翻译成少数民族语言文字作品在国内出版发行； ​ （十二）将已经发表的作品改成盲文出版。 ​ 前款规定适用于对出版者、表演者、录音录像制作者、广播电台、电视台的权利的限制。 著作权是一个很大的概念​ 第十条 著作权包括下列人身权和财产权： ​ （一）发表权，即决定作品是否公之于众的权利； ​ （二）署名权，即表明作者身份，在作品上署名的权利； ​ （三）修改权，即修改或者授权他人修改作品的权利； ​ （四）保护作品完整权，即保护作品不受歪曲、篡改的权利； ​ （五）复制权，即以印刷、复印、拓印、录音、录像、翻录、翻拍等方式将作品制作一份或者多份的权利； ​ （六）发行权，即以出售或者赠与方式向公众提供作品的原件或者复制件的权利； ​ （七）出租权，即有偿许可他人临时使用电影作品和以类似摄制电影的方法创作的作品、计算机软件的权利，计算机软件不是出租的主要标的的除外； ​ （八）展览权，即公开陈列美术作品、摄影作品的原件或者复制件的权利； ​ （九）表演权，即公开表演作品，以及用各种手段公开播送作品的表演的权利； ​ （十）放映权，即通过放映机、幻灯机等技术设备公开再现美术、摄影、电影和以类似摄制电影的方法创作的作品等的权利； ​ （十一）广播权，即以无线方式公开广播或者传播作品，以有线传播或者转播的方式向公众传播广播的作品，以及通过扩音器或者其他传送符号、声音、图像的类似工具向公众传播广播的作品的权利； ​ （十二）信息网络传播权，即以有线或者无线方式向公众提供作品，使公众可以在其个人选定的时间和地点获得作品的权利； ​ （十三）摄制权，即以摄制电影或者以类似摄制电影的方法将作品固定在载体上的权利； ​ （十四）改编权，即改变作品，创作出具有独创性的新作品的权利； ​ （十五）翻译权，即将作品从一种语言文字转换成另一种语言文字的权利； ​ （十六）汇编权，即将作品或者作品的片段通过选择或者编排，汇集成新作品的权利； ​ （十七）应当由著作权人享有的其他权利。 ​ 著作权人可以许可他人行使前款第（五）项至第（十七）项规定的权利，并依照约定或者本法有关规定获得报酬。 ​ 著作权人可以全部或者部分转让本条第一款第（五）项至第（十七）项规定的权利，并依照约定或者本法有关规定获得报酬。 大致分类 再发行 创作演绎作品 放弃著作权的部分权利公有领域完全自由使用，和著作者没有任何关系。 著作权的强制放弃这部分主要想说的是著作权到期： 第二十条 作者的署名权、修改权、保护作品完整权的保护期不受限制。 ​ 第二十一条 公民的作品，其发表权、本法第十条第一款第（五）项至第（十七）项规定的权利的保护期为作者终生及其死亡后五十年，截止于作者死亡后第五十年的12月31日；如果是合作作品，截止于最后死亡的作者死亡后第五十年的12月31日。 ​ 法人或者其他组织的作品、著作权（署名权除外）由法人或者其他组织享有的职务作品，其发表权、本法第十条第一款第（五）项至第（十七）项规定的权利的保护期为五十年，截止于作品首次发表后第五十年的12月31日，但作品自创作完成后五十年内未发表的，本法不再保护。 ​ 电影作品和以类似摄制电影的方法创作的作品、摄影作品，其发表权、本法第十条第一款第（五）项至第（十七）项规定的权利的保护期为五十年，截止于作品首次发表后第五十年的12月31日，但作品自创作完成后五十年内未发表的，本法不再保护。 原创性门槛是指一部作品是经作者独立创作产生的，是作者独立构思的产物，而不是对已有作品的抄袭。 不满足原创性就不具备著作权 比如google、eondrive、sony的logo就不满足原创性。 但是随意使用违反了商标权 商标权和著作权是分割的 主动放弃著作权自由版权内容完全自由的使用、衍生 Creative commons创用CC，commons是类似众议院中的意思，主要提供了几种核心的版权协议：BY SA ND NC 避风港规则通知-删除规则，侵权的话，作者通知的话只要删除就好。 本文作者： ArrogantL (arrogant262@gmail.com) 版权声明： 本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。转载请注明出处！]]></content>
  </entry>
  <entry>
    <title><![CDATA[String到底在内存中是如何存储的]]></title>
    <url>%2FString%E5%88%B0%E5%BA%95%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E7%9A%84%2F</url>
    <content type="text"><![CDATA[String会出现在哪些地方方法内的局部string类内的字段Stringstatic string容器中存储的stringString数组那么String的位置会影响其存储方式吗？显然是不会的，类永远只会储存在堆上。但是实际上类的字段并不是一直在堆上的。String的构造方法以下来自String类 源码，一些无关紧要的实现被我省略了： private final char value[]; private int hash; // Default to 0 private static final long serialVersionUID = -6849794470754667710L; private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0]; public String() { this.value = “”.value; } public String(String original) { this.value = original.value;//底层char[]指向了同一位置！ this.hash = original.hash; } public String(char value[]) { this.value = Arrays.copyOf(value, value.length);//底层char[]指向不同位置！下面的截取也是如此 } public String(char value[], int offset, int count) { … } public String(int[] codePoints, int offset, int count) {...} public String(byte ascii[], int hibyte, int offset, int count) {...} public String(byte ascii[], int hibyte) {...} 我们可以发现String的构造器并不关注是否将char[]指向同一位置，之所以有一些没有指向同一位置完全是为了保证char[]是immutable的。这并不能说明调用构造器构造的String的内存位置有什么特别之处。 String另一种构造方式–为包装类型提供的专有构造方式运行如下代码： class StringPointerTest{ String g=”gh”,h=”gh”;}public class StringTest { public static void main(String[] args) { String a=”abc”; String b=”abc”; System.out.println(a==b);//true使用简写的构造能够复用创建的string类 String c=new String(“abc”); System.out.println(a==c);//false是用构造器则不能 String d=new String(“def”); String e=”def”； System.out.println(d==e);//false即使先构造器再使用简化构造也不行。 StringPointerTest spt=new StringPointerTest(); System.out.println(spt.g==spt.h); //true与String的属于方法局部变量还是类字段也无关 }}class IntegerPointTest1{ Integer a=1; }class IntegerPointTest2{ Integer b=1;}public class IntegerTest { public static void main(String[] args) { System.out.println(new IntegerPointTest1().a==new IntegerPointTest2().b);//true! }}原理需要存储的代码元素有： Class类文件方法，类的所以实例应该共用一段方法static字段字符串常量值常量类实例各种引用基本变量他们各自有各自的存储位置，方法内的引用存在方法栈，类内的引用存在堆，类存储在堆上，方法中的局部基本变量存于栈但是类字段的基本变量存在堆上（方法区内）。值得一提的是方法区（又叫静态区），其存储值常量、字符串常量、方法、静态字段、.class文件，等只用一个备份的数据。栈和方法区都有共享数据的功能。因此使用简化方法构造String类的时候，在方法内和类内会将字符串存于栈/方法区，这无关紧要，重要的是，使用这种构造方法，如果没有所构造的字符串常量存在于内存中，那么会在栈/方法区中存上一份，然后再堆中新建一个String类，把String类的char[]引用指向在栈/方法区中的字符串常量；如果所构造的字符串常量已经存在于内存中，那么则会检索关联与之对应的堆中String实例，并直接使用这个String类实例。只有使用简化方法构造才能被栈/方法区记录下来，如果使用new则不行，这也是为什么上例即使先new，再使用简化构造相同字符串也不会引用相同。因为new出来的String实例的字符串常量存储在堆上，和栈/方法区无关。拓展到所有包装类型—可以吗？完全不可以。他们都没有像String那样实现缓存。但是实现了类似的缓存，它们的自动包装机制也提供缓存功能，但是是基于valueof方法的，该方法会对一定范围内进行缓存。而且实现方式非常暴力,是在对应类里存一个静态的类数组，并静态初始化全部填充。 可以缓存的范围：byte Byte -128–127short Short -128–127int Integer -128—127long Long -128—127char Character 0–127boolean Boolean TURE，FALSEString不缓存的：float Floatdouble Double 可见不是所有的自动包装机制都实现了全缓存。]]></content>
      <categories>
        <category>java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>包装类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scanner分析]]></title>
    <url>%2FScanner%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[scanner错误关闭导致的异常public class test2 { public static void main(String[] args) { Scanner scanner1 = new Scanner(System.in); System.out.println(“run scanner1.close()”); scanner1.close(); Scanner scanner2 = new Scanner(System.in); System.out.println(&quot;run scanner2.nextLine()&quot;); scanner2.nextLine(); }}但是会在scanner2.nextLine()调用时抛出异常java.util.NoSuchElementException: No line found 原因下面是scanner的源码 // The input source private Readable source;public void close() { if (closed) return; if (source instanceof Closeable) { try { ((Closeable)source).close(); } catch (IOException ioe) { lastException = ioe; } } sourceClosed = true; source = null; closed = true; }所以调用close方法并不仅仅关闭scanner类，同时关闭了初始化时作为参数传入的Readable对象。在示例代码中scanner1.close();关闭了System.in，所以虽然初始化scanner2没有问题，但是readLine()会报错。 是否可以通过重新开启System.in的方式补救呢？遗憾的是，至少作为java的使用者来说是不可以的，除非我们能控制jvm运行。这涉及到System.in是如何开启的，简单来说因为System.in是特殊的系统资源，由jvm负责开启,无法通过java代码重新初始化System.in。如果查看System.in的代码我们就能发现它通过native方法实现初始化，在native方法中将控制台或文件句柄传输给System.in来完成。同样的,Systerm.out System.err也是无法重新被开启的资源，对于它们，close方法应该被谨慎的调用。（ps：实际上有什么原因关闭呢？） 让我们把问题拓展开来实际上，所有的能够以System.in/out/err为构造器参数的包装器类的close方法都应该被考虑，可以看到jdk的设计者并没有区别对待普通的流和System.in/out/err，而包装器类的close方法关闭底层流对于普通流来说是很合理的，因此我们可以推测事实上其他的包装器的close方法也可能导致关闭System.in/out/err。常用的bufferinputstream就是如此。 jdk7引入的带资源的try语法糖产生隐蔽的问题jdk7引入的带资源的try语法糖隐式的帮助程序员调用close方法,遗憾的是该方法也会产生上述问题，甚至更难被发现。 我们有必要积极的关闭不再需要的流嘛？如何对待io.close?如何预防该问题？从性能的角度来说，积极关闭流是必须的，实际上如果我们使用findbugs等代码规范工具，能发现关闭io是被强烈推荐的。如果你使用idea的话，建议在close之前，使用快捷键ctrl+b进入close方法的源代码来查看其关闭机制。这种方法非常简便，当然eclipse应该也有插件可以实现类似功能。我们也可以通过包装System.in/out/err来安全的使用它们，实际上利用装饰器模式，覆盖System.in/out/err的close方法即可。]]></content>
      <categories>
        <category>java</category>
        <category>内存模型</category>
      </categories>
      <tags>
        <tag>scanner</tag>
        <tag>底层</tag>
      </tags>
  </entry>
</search>
